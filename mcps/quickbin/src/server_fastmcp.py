"""
QuickBin MCP Server using FastMCP

This server provides QuickBin metagenomics binning tools through the Model Context Protocol (MCP).
QuickBin bins contigs using coverage and kmer frequencies for metagenomics analysis.
"""

from fastmcp import FastMCP
import json
import logging
import sys
from pathlib import Path

# Add the parent directory to the path for imports
sys.path.insert(0, str(Path(__file__).parent))

from quickbin_tools import QuickBinToolkit
# Import tool schemas (handle both relative and direct imports)
try:
    from .tool_schema import get_tool_schemas, get_resource_schemas
except ImportError:
    from tool_schema import get_tool_schemas, get_resource_schemas

logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger(__name__)

# Reduce FastMCP logging noise during startup
logging.getLogger('fastmcp').setLevel(logging.WARNING)
logging.getLogger('mcp').setLevel(logging.WARNING)

# Create FastMCP server
mcp = FastMCP("QuickBin Tools ðŸ—‚ï¸")
toolkit = QuickBinToolkit()

@mcp.tool
async def bin_contigs(
    contigs_path: str,
    sam_files: list[str],
    output_pattern: str,
    stringency: str = "normal",
    additional_params: str | None = None
) -> dict:
    """Bin contigs using coverage and kmer frequencies with QuickBin

    Args:
        contigs_path: Path to assembled contigs file (FASTA format)
        sam_files: List of SAM/BAM alignment files for coverage calculation
        output_pattern: Output pattern for bins (e.g., "bin%.fa" or "bins/")
        stringency: Binning stringency (xstrict, strict, normal, loose, xloose)
        additional_params: Additional QuickBin parameters (optional)
    """
    logger.info(f"Binning contigs from {contigs_path} using {len(sam_files)} SAM files")
    return await toolkit.bin_contigs(
        contigs_path=contigs_path,
        sam_files=sam_files,
        output_pattern=output_pattern,
        stringency=stringency,
        additional_params=additional_params
    )

@mcp.tool
async def bin_contigs_with_coverage(
    contigs_path: str,
    coverage_file: str,
    output_pattern: str,
    stringency: str = "normal",
    additional_params: str | None = None
) -> dict:
    """Bin contigs using pre-calculated coverage file

    Args:
        contigs_path: Path to assembled contigs file (FASTA format)
        coverage_file: Path to coverage file generated by QuickBin or similar tool
        output_pattern: Output pattern for bins (e.g., "bin%.fa" or "bins/")
        stringency: Binning stringency (xstrict, strict, normal, loose, xloose)
        additional_params: Additional QuickBin parameters (optional)
    """
    logger.info(f"Binning contigs from {contigs_path} using coverage file {coverage_file}")
    return await toolkit.bin_contigs_with_coverage(
        contigs_path=contigs_path,
        coverage_file=coverage_file,
        output_pattern=output_pattern,
        stringency=stringency,
        additional_params=additional_params
    )

@mcp.tool
async def generate_coverage(
    contigs_path: str,
    sam_files: list[str],
    output_coverage: str,
    additional_params: str | None = None
) -> dict:
    """Generate coverage statistics from SAM files for later binning

    Args:
        contigs_path: Path to assembled contigs file (FASTA format)
        sam_files: List of SAM/BAM alignment files
        output_coverage: Output path for coverage file
        additional_params: Additional parameters for coverage calculation
    """
    logger.info(f"Generating coverage from {len(sam_files)} SAM files")
    return await toolkit.generate_coverage(
        contigs_path=contigs_path,
        sam_files=sam_files,
        output_coverage=output_coverage,
        additional_params=additional_params
    )

@mcp.tool
async def evaluate_bins(
    bin_directory: str,
    reference_taxonomy: str | None = None,
    additional_params: str | None = None
) -> dict:
    """Evaluate binning quality and completeness

    Args:
        bin_directory: Directory containing binned contigs
        reference_taxonomy: Optional reference taxonomy for validation
        additional_params: Additional evaluation parameters
    """
    logger.info(f"Evaluating bins in {bin_directory}")
    return await toolkit.evaluate_bins(
        bin_directory=bin_directory,
        reference_taxonomy=reference_taxonomy,
        additional_params=additional_params
    )

@mcp.resource("quickbin://docs/user-guide")
async def get_user_guide() -> str:
    """Get QuickBin user guide documentation"""
    return """# QuickBin User Guide

## Overview
QuickBin bins contigs using coverage and kmer frequencies for metagenomics analysis. It groups assembled sequences into taxonomically coherent clusters (bins) representing individual genomes.

## Basic Usage

### 1. Simple Binning with SAM Files
Bin contigs using alignment files:
```
bin_contigs(
    contigs_path="/path/to/contigs.fa",
    sam_files=["/path/to/sample1.sam", "/path/to/sample2.sam"],
    output_pattern="bin%.fa",
    stringency="normal"
)
```

### 2. Two-Step Process: Coverage + Binning
Generate coverage first, then bin:
```
# Step 1: Generate coverage
generate_coverage(
    contigs_path="/path/to/contigs.fa",
    sam_files=["/path/to/sample1.sam", "/path/to/sample2.sam"],
    output_coverage="coverage.txt"
)

# Step 2: Bin using coverage file
bin_contigs_with_coverage(
    contigs_path="/path/to/contigs.fa",
    coverage_file="coverage.txt",
    output_pattern="bins/",
    stringency="normal"
)
```

### 3. Evaluate Binning Quality
Assess the quality of your bins:
```
evaluate_bins(
    bin_directory="bins/",
    reference_taxonomy="taxonomy.txt"
)
```

## Stringency Levels
- **xstrict**: Highest purity, lowest completeness
- **strict**: High purity
- **normal**: Balanced (default, <1% contamination)
- **loose**: Higher completeness
- **xloose**: Highest completeness, comparable to other binners

## Output Formats
- `bin%.fa`: Creates separate files (bin1.fa, bin2.fa, etc.)
- `bins/`: Creates files in a directory
- `output.fa`: Single file with bin annotations

## Best Practices
1. Use multiple SAM files from different samples for better binning
2. Ensure good mapping quality (use minid=0.9, maxindel=10 in bbmap)
3. Start with 'normal' stringency and adjust based on needs
4. Use evaluate_bins to assess quality
"""

@mcp.resource("quickbin://examples/metagenome-workflow")
async def get_metagenome_workflow() -> str:
    """Get example metagenome binning workflow"""
    return """# Complete Metagenome Binning Workflow

This workflow demonstrates a complete metagenome assembly and binning pipeline:

## Prerequisites
You should have:
- Assembled contigs (from SPAdes, metaSPAdes, or similar)
- SAM files from mapping reads back to contigs (from bbmap)

## Step 1: Generate Coverage File (Optional but Recommended)
```python
# Generate coverage statistics for reuse
coverage_result = await generate_coverage(
    contigs_path="assembly/contigs.fasta",
    sam_files=["mapping/sample1.sam", "mapping/sample2.sam", "mapping/sample3.sam"],
    output_coverage="coverage_stats.txt"
)
print(f"Coverage generated: {coverage_result['status']}")
```

## Step 2: Bin Contigs
```python
# Option A: Direct binning with SAM files
binning_result = await bin_contigs(
    contigs_path="assembly/contigs.fasta",
    sam_files=["mapping/sample1.sam", "mapping/sample2.sam", "mapping/sample3.sam"],
    output_pattern="bins/bin%.fa",
    stringency="normal",
    additional_params="mincluster=50k minseed=3000"
)

# Option B: Using pre-calculated coverage
binning_result = await bin_contigs_with_coverage(
    contigs_path="assembly/contigs.fasta",
    coverage_file="coverage_stats.txt",
    output_pattern="bins/bin%.fa",
    stringency="normal"
)

print(f"Generated {binning_result['bin_stats']['total_bins']} bins")
print(f"Largest bin: {binning_result['bin_stats']['largest_bin_size']} bp")
```

## Step 3: Evaluate Binning Quality
```python
# Assess binning quality
evaluation_result = await evaluate_bins(
    bin_directory="bins/",
    additional_params="validate=t sketchoutput=t"
)

print(f"Average completeness: {evaluation_result['quality_stats']['avg_completeness']}%")
print(f"Average contamination: {evaluation_result['quality_stats']['avg_contamination']}%")
```

## Expected Results
- Normal stringency typically produces bins with >90% completeness and <5% contamination
- Larger metagenomes may produce 10-100+ bins depending on complexity
- Each bin represents a potential microbial genome or population

## Tips for Success
1. **Multiple samples improve binning**: Use at least 3 SAM files from different samples
2. **Quality mapping**: Ensure good alignment quality (>90% identity)
3. **Appropriate stringency**: Start with 'normal', use 'loose' for higher completeness
4. **Memory considerations**: Large metagenomes may need 32GB+ RAM
5. **Iterate**: Try different stringency levels and compare results
"""

@mcp.resource("quickbin://tools/available")
async def get_available_tools() -> str:
    """Get list of available QuickBin tools"""
    tools_info = {
        "core_tools": [
            {
                "name": "bin_contigs",
                "description": "Bin contigs using SAM files",
                "primary_use": "Metagenome binning"
            },
            {
                "name": "bin_contigs_with_coverage",
                "description": "Bin contigs using pre-calculated coverage",
                "primary_use": "Fast re-binning"
            },
            {
                "name": "generate_coverage",
                "description": "Generate coverage statistics from SAM files",
                "primary_use": "Coverage analysis"
            },
            {
                "name": "evaluate_bins",
                "description": "Evaluate binning quality and completeness",
                "primary_use": "Quality assessment"
            }
        ],
        "stringency_levels": [
            "xstrict - Highest purity",
            "strict - High purity",
            "normal - Balanced (default)",
            "loose - Higher completeness",
            "xloose - Highest completeness"
        ],
        "container_info": {
            "image": "bryce911/bbtools:latest",
            "runtime": "shifter",
            "command_prefix": "shifter --image bryce911/bbtools:39.27 quickbin.sh"
        },
        "input_requirements": {
            "contigs": "FASTA format assembly file",
            "alignments": "SAM/BAM files from read mapping",
            "coverage": "Optional pre-calculated coverage file"
        },
        "output_formats": {
            "pattern_based": "bin%.fa creates bin1.fa, bin2.fa, etc.",
            "directory_based": "bins/ creates files in directory",
            "single_file": "output.fa with bin annotations"
        }
    }

    return json.dumps(tools_info, indent=2)

@mcp.resource("quickbin://parameters/stringency")
async def get_stringency_guide() -> str:
    """Get detailed stringency parameter guide"""
    return """# QuickBin Stringency Guide

## Stringency Levels (from strict to loose)

### xstrict (Extra Strict)
- **Use case**: Maximum purity required
- **Trade-off**: Lowest completeness, many small bins
- **Contamination**: <0.1%
- **Best for**: Reference genome construction

### strict (Strict)
- **Use case**: High-quality bins needed
- **Trade-off**: Lower completeness
- **Contamination**: <0.5%
- **Best for**: Functional analysis requiring high confidence

### normal (Default)
- **Use case**: Balanced approach
- **Trade-off**: Good balance of completeness and purity
- **Contamination**: <1%
- **Best for**: Most metagenomics applications

### loose (Loose)
- **Use case**: Maximize genome recovery
- **Trade-off**: Higher contamination acceptable
- **Contamination**: 1-5%
- **Best for**: Community analysis, phylogenetics

### xloose (Extra Loose)
- **Use case**: Maximum completeness
- **Trade-off**: Higher contamination
- **Contamination**: 2-10%
- **Best for**: Comparative studies with other binners

## Selection Guidelines

1. **Start with 'normal'** - Good default for most applications
2. **Use 'strict'** - If downstream analysis is sensitive to contamination
3. **Use 'loose'** - If you need maximum genome recovery
4. **Compare multiple levels** - Run with different stringencies and evaluate
5. **Consider downstream use** - Match stringency to your analysis needs

## Parameters You Can Adjust

- `mincluster=50k` - Minimum bin size
- `minseed=3000` - Minimum contig length for new clusters
- `cutoff=0.52` - Neural network threshold
- `gcwidth=0.02` - GC content quantization
- `depthwidth=0.5` - Coverage depth quantization
"""

if __name__ == "__main__":
    # Run the MCP server
    mcp.run()
